//! Universal Serial Bus (USB)

#[cfg_attr(usb, path = "usb.rs")]
#[cfg_attr(otg, path = "otg.rs")]
mod _version;
pub use _version::*;

use crate::interrupt::typelevel::Interrupt;
use crate::rcc::sealed::RccPeripheral;

/// clock, power initialization stuff that's common for USB and OTG.
fn common_init<T: Instance>() {
    #[cfg(any(stm32l4, stm32l5, stm32wb))]
    critical_section::with(|_| crate::pac::PWR.cr2().modify(|w| w.set_usv(true)));

    #[cfg(pwr_h5)]
    critical_section::with(|_| crate::pac::PWR.usbscr().modify(|w| w.set_usb33sv(true)));

    #[cfg(stm32h7)]
    {
        // If true, VDD33USB is generated by internal regulator from VDD50USB
        // If false, VDD33USB and VDD50USB must be suplied directly with 3.3V (default on nucleo)
        // TODO: unhardcode
        let internal_regulator = false;

        // Enable USB power
        critical_section::with(|_| {
            crate::pac::PWR.cr3().modify(|w| {
                w.set_usb33den(true);
                w.set_usbregen(internal_regulator);
            })
        });

        // Wait for USB power to stabilize
        while !crate::pac::PWR.cr3().read().usb33rdy() {}
    }

    #[cfg(stm32u5)]
    {
        // Enable USB power
        critical_section::with(|_| {
            crate::pac::PWR.svmcr().modify(|w| {
                w.set_usv(true);
                w.set_uvmen(true);
            })
        });

        // Wait for USB power to stabilize
        while !crate::pac::PWR.svmsr().read().vddusbrdy() {}
    }

    T::Interrupt::unpend();
    unsafe { T::Interrupt::enable() };

    <T as RccPeripheral>::enable_and_reset();
}
