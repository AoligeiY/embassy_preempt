# r-ucosii设计文档

## 整体设计

分成两个接口，一个接口是对于c/rust的普通函数的，另一个接口是对于rust的异步函数的。

然而对于c/rust普通函数，我们对它进行包装，在接口内转为一个future 对象，从而将调度都统一到执行器进行。

后续可以通过宏或者接口中直接区别rust的普通函数和异步函数从而对于rust普通函数和异步函数进行合并

下面以表格形式给出各种情况的上下文切换情况：

| 当前执行现场 | 新执行现场       | 切换条件 | 是否需要保存上下文 | 是否需要恢复上下文 |
| ------------ | ---------------- | -------- | ------------------ | ------------------ |
| 协程         | 线程             | await    | 否                 | 是                 |
| 协程         | 协程（未被打断） | await    | 否                 | 否                 |
| 协程         | 协程（被打断）   | await    | 否                 | 是                 |
|              |                  |          |                    |                    |
| 协程/线程    | 线程             | 非await  | 是                 | 是                 |
| 协程/线程    | 协程（未被打断） | 非await  | 是                 | 否                 |
| 协程/线程    | 协程（被打断）   | 非await  | 是                 | 是                 |

### 栈部分的分析
首先将上下文切换的分类分成抢占和让权两种；
在对于抢占的时候需要分为保存和恢复两步：

- 对于保存：不管什么情况，都是先给当前任务分配一个堆栈，然后将当前任务的上下文保存到堆栈中
- 对于恢复： 需要先判定需要转移的任务是否有堆栈，如果没有，说明是协程，那么直接poll就能恢复调度执行，而对于有堆栈的情况，需要将堆栈中的上下文恢复到寄存器中（这里面就包括了pc的恢复从而跳转到任务执行）

仔细考虑一下栈的动态分配问题：
> 对于普通的线程，通常由用户指定一个栈的区域，从而我们将栈分配给任务，但是这样的话，我们无法做到栈的动态分配，我想做到在可能的情况下，如果不存在抢占，那么所有的线程以及协程都是共用一套栈，等到遇到抢占的时候再分配

动态分配时，首先所有的协程以及线程（实际上我们也把线程处理为了一个没有await点的协程从而做到统一的调度），都是共用一套栈，当遇到抢占的时候，我们需要将当前任务的栈保存起来，也就是说之前协程共用的这一套栈被分给了当前任务用于它的上下文保存，接着因为原来的栈被占用，我们需要重新分配一个栈给原来运行的所有协程（这和即将恢复运行的协程不一定就是同一个栈）
> 这里说明为什么恢复运行后的任务的栈不一定就是所有协程所在的栈（也就是说恢复后的任务不一定就变成协程）：因为恢复的任务可能之前是被抢占的，那么恢复的时候就需要从堆栈中恢复上下文（包括pc与sp等）从而继续执行。而这里注意，是不可以在恢复现场的时候释放掉栈的，因为还有一些现场本身是放在栈里面的，这个栈需要继续使用，但是继续执行之后，如果遇到await（也就主动让权的情况）或者整个任务完成退出，那么就可以释放掉自己使用的栈到栈池了。

这里实际上最关键的就是这个栈分配器的实现，我感觉这里就和堆分配器一样（实际上就是堆分配了已经），考虑就直接用堆分配器

# 第一阶段
在uCOS中**没有中断的场景**下，引入embassy，以支持协程；（线程被视为不会暂停的协程）
- 统一线程和协程的控制块结构TCB（Task Control Block）；
- 只有让权情况出现，让权时栈空，可以复用栈；（解决堆栈的分配和回收问题）
